<#
.SYNOPSIS
    Creates a new cabinet .CAB file on disk.

.DESCRIPTION
    This cmdlet creates a new cabinet .CAB file using MAKECAB.EXE and adds
    all the files specified to the cabinet file itself.

.PARAMETER Name
    The output file name of the cabinet .CAB file, such as MyNewCabinet.cab.
    This should not be the entire file path, only the target file name.

.PARAMETER Source
    One or more file references that are to be added to the cabinet .CAB file.
    FileInfo objects (as generated by Get-Item etc) or strings can be passed
    in via the pipeline to be added to the cabinet file.

.PARAMETER Destination
    The output file path that the cabinet file will be saved in. It is also
    used for resolving any ambiguous file references, i.e. any file passed in
    via file name and not full path.

    If not specified the current working directory is used for the output file
    and attempting to resolve all ambiguous file references.

.PARAMETER NoClobber
    Will not overwrite of an existing file. By default, if a file exists in the
    specified path, New-CabinetFile overwrites the file without warning.

.EXAMPLE
    New-CabinetFile -Name MyCabinet.cab -File "File01.exe","File02.txt"
    
    This creates a new MyCabinet.cab file in the current directory and adds the File01.exe and File02.txt files to it, also from the current directory.
.EXAMPLE
    New-CabinetFile -Name MyCabinet.cab -Source "C:\Demo"

    This creates a new MyCabinet.cab file in the current directory and adds all items found in the source folder.

.LINK
    https://virtualengine.co.uk/creating-cab-files-with-powershell/ 
#>
[CmdletBinding()]
    Param(
        [Parameter(HelpMessage = "Name of the cabinet file including .CAB extension.", Position = 1, Mandatory = $false, ValueFromPipelineByPropertyName = $true)]
        [Alias("FilePath")]
        [string] $Name = ((Get-Date -Format "yyyyMMddTHHmmssffff") + ".cab"),

        [Parameter(HelpMessage = "Source folder to items to include in cabinet file.", Position = 0, Mandatory = $true, ValueFromPipeline = $true)]
        [ValidateNotNullOrEmpty()]
        [Alias("FullName")]
        [string] $Source,

        [Parameter(HelpMessage = "Optional destination directory for cabinet file.", Position = 2, ValueFromPipelineByPropertyName = $true)]
        [string] $Destination = $PSScriptRoot,

        [Parameter(HelpMessage = "Do not overwrite any existing .cab file.")]
        [Switch] $NoClobber
    )
$ddfFile = Join-Path -path $destination -ChildPath temp.ddf
Function New-DDF() {
  [string]$message = $null
  [string]$temp = $null
  #region ddfhead
  
  [string]$message = "Create ddfheader file"
  Write-Host $message
  Write-Debug $message
  [string]$ddfHeader = @"
;*** MakeCAB Directive file
;
.OPTION EXPLICIT  
.Set CabinetNameTemplate=$name
.Set DiskDirectoryTemplate = $destination
.Set Cabinet=on
.Set Compress=off
.Set CabinetFileCountThreshold=0 
.Set FolderFileCountThreshold=0
.Set FolderSizeThreshold=0 
.Set MaxCabinetSize=0 
.Set MaxDiskFileCount=0 
.Set MaxDiskSize=0

.Set DestinationDir= ;
"@
  #endregion

  #region body
  $message = "Writing ddfheader to $ddfFile"
  Write-Host $message
  Write-Debug $message
    
  $temp = $ddfHeader
  Write-Host $temp
  $message = "Generating collection of files from $source"
  Write-Host $message
  Write-Debug $message

  # add items to ddfFile
  $temp += $([char]10)
  $temp += $([char]10)
  Get-ChildItem $source -File | ForEach-Object { 
    # items in the root of source directory
    Write-Host $_.Name
    $temp += $([char]34) + $_.fullname.tostring() + $([char]34) + $([char]10)
  }
  # create a new destination directory for each sub directory
  Get-ChildItem $source -Directory -Recurse | ForEach-Object {

    # if the directory has no files, skip it
    if ($_.GetFiles().Count) {
      # get directory names and add to Set Destination Folder property
      $folder = $_ | Split-Path -Leaf
      $folder = $folder.TrimStart('\')
      $folder = $([char]34) + $folder + $([char]34)
      Write-Host $folder
      $temp += $([char]10) + ".Set DestinationDir=$folder" + $([char]10)

      # place the files for each sub directory under its destination directory entry
      Get-ChildItem $_.pspath -File | ForEach-Object { 
        Write-Host $_.Name
        $temp += $([char]34) + $_.fullname.tostring() + $([char]34) + $([char]59) + $([char]10)
      }
    }
  }
  #endregion

  #region ouput
    
  $message = "Output to file"
  Write-Host $message
  Write-Debug $message
  return Set-Content -Path $ddfFile -Value $temp -Encoding ASCII -Force
  #endregion
}
New-DDF

Function New-Cab($file) {
#region makecab
    Write-Debug "Entering the New-Cab function. The DDF File is $file"
    if ($debug)
    { 
        makecab /f $file /V3
    }
    Else
    { 
        makecab /f $file
    }

    If (Test-Path -Path ./Disk1/$name)
    {
        Move-Item -Path ./Disk1/$name -Destination $Destination/$Name
    }
#endregion
} 
New-Cab $ddfFile